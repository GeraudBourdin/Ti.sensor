/**
 * This file was auto-generated by the Titanium Module SDK helper for Android
 * Appcelerator Titanium Mobile
 * Copyright (c) 2009-2010 by Appcelerator, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 *
 */
package com.geraudbourdin.sensor;




import org.appcelerator.kroll.KrollDict;
import org.appcelerator.kroll.KrollModule;
import org.appcelerator.kroll.KrollProxy;
import org.appcelerator.kroll.annotations.Kroll;
import org.appcelerator.titanium.util.TiSensorHelper;
import org.appcelerator.titanium.util.TiUIHelper;
import org.appcelerator.titanium.TiApplication;
import org.appcelerator.kroll.common.Log;

import android.content.Context;
import android.hardware.Sensor;
import android.hardware.SensorEvent;
import android.hardware.SensorEventListener;
import android.hardware.SensorManager;
import android.hardware.TriggerEvent;
import android.hardware.TriggerEventListener;
// Brightness.
import android.content.ContentResolver;
import android.provider.Settings;
import android.provider.Settings.SettingNotFoundException;
import android.view.WindowManager;
import android.view.Window;

// Flash light
import android.hardware.Camera;
import android.hardware.Camera.Parameters;
import android.media.MediaPlayer;
import android.media.MediaPlayer.OnCompletionListener;
import android.content.pm.PackageManager;
import android.app.Activity;

import java.util.List;

import com.geraudbourdin.sensor.MeanFilter;

@Kroll.module(name="Sensor", id="com.geraudbourdin.sensor")
public class SensorModule extends KrollModule implements SensorEventListener
{

	private static final String LCAT = "SensorModule";
	SensorManager sensorManager;

	// For significant motion Sensor only.
	private Sensor mSensor;
	private TriggerEventListener mTriggerEventListener;

	private static final String EVENT_UPDATE = "update";

	@Kroll.constant
	public static final int TYPE_ACCELEROMETER = Sensor.TYPE_ACCELEROMETER;
	@Kroll.constant
    public static final int TYPE_ALL = Sensor.TYPE_ALL;
	@Kroll.constant
	public static final int TYPE_AMBIENT_TEMPERATURE = Sensor.TYPE_AMBIENT_TEMPERATURE;
	@Kroll.constant
	public static final int TYPE_GAME_ROTATION_VECTOR = Sensor.TYPE_GAME_ROTATION_VECTOR;
	@Kroll.constant
	public static final int TYPE_GEOMAGNETIC_ROTATION_VECTOR = Sensor.TYPE_GEOMAGNETIC_ROTATION_VECTOR;
	@Kroll.constant
	public static final int TYPE_GRAVITY = Sensor.TYPE_GRAVITY;
	@Kroll.constant
	public static final int TYPE_GYROSCOPE = Sensor.TYPE_GYROSCOPE;
	@Kroll.constant
	public static final int TYPE_GYROSCOPE_UNCALIBRATED = Sensor.TYPE_GYROSCOPE_UNCALIBRATED;
	//@Kroll.constant
	//public static final int TYPE_HEART_RATE = Sensor.TYPE_HEART_RATE;
	@Kroll.constant
	public static final int TYPE_LIGHT = Sensor.TYPE_LIGHT;
	@Kroll.constant
	public static final int TYPE_LINEAR_ACCELERATION = Sensor.TYPE_LINEAR_ACCELERATION;
	@Kroll.constant
	public static final int TYPE_MAGNETIC_FIELD = Sensor.TYPE_MAGNETIC_FIELD;
	@Kroll.constant
	public static final int TYPE_MAGNETIC_FIELD_UNCALIBRATED = Sensor.TYPE_MAGNETIC_FIELD_UNCALIBRATED;
	@Kroll.constant
	public static final int TYPE_PROXIMITY = Sensor.TYPE_PROXIMITY;
	@Kroll.constant
	public static final int TYPE_RELATIVE_HUMIDITY = Sensor.TYPE_RELATIVE_HUMIDITY;
	@Kroll.constant
	public static final int TYPE_ROTATION_VECTOR = Sensor.TYPE_ROTATION_VECTOR;
	@Kroll.constant
	public static final int TYPE_SIGNIFICANT_MOTION = Sensor.TYPE_SIGNIFICANT_MOTION;
	@Kroll.constant
	public static final int TYPE_STEP_COUNTER = Sensor.TYPE_STEP_COUNTER;
	@Kroll.constant
	public static final int TYPE_STEP_DETECTOR = Sensor.TYPE_STEP_DETECTOR;
	@Kroll.constant
	public static final int TYPE_ORIENTATION = Sensor.TYPE_ORIENTATION;
	@Kroll.constant
	public static final int SCREEN_BRIGHTNESS_MODE_MANUAL = Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL;
	@Kroll.constant
	public static final int SCREEN_BRIGHTNESS_MODE_AUTOMATIC = Settings.System.SCREEN_BRIGHTNESS_MODE_AUTOMATIC;


	private boolean accelerometerRegistered = false;
	private boolean accelerometerEnabled = false;

	private boolean magneticFieldRegistered = false;
	private boolean magneticFieldEnabled = false;

	private boolean ambiantTemperatureRegistered = false;
	private boolean ambiantTemperatureEnabled = false;

	private boolean gameRotationVectorRegistered = false;
	private boolean gameRotationVectorEnabled = false;

	private boolean geomagneticRotationVectorRegistered = false;
	private boolean geomagneticRotationVectorEnabled = false;

	private boolean gravityRegistered = false;
	private boolean gravityEnabled = false;

	private boolean gyroscopeRegistered = false;
	private boolean gyroscopeEnabled = false;

	private boolean gyroscopeUncalibratedRegistered = false;
	private boolean gyroscopeUncalibratedEnabled = false;

	//private boolean heartRateRegistered = false;
	//private boolean heartRateEnabled = false;

	private boolean lightRegistered = false;
	private boolean lightEnabled = false;

	private boolean linearAccelerationRegistered = false;
	private boolean linearAccelerationEnabled = false;

	private boolean magneticFieldUncalibratedRegistered = false;
	private boolean magneticFieldUncalibratedEnabled = false;

	private boolean orientationRegistered = false;
	private boolean orientationEnabled = false;

	private boolean pressureRegistered = false;
	private boolean pressureEnabled = false;

	private boolean proximityRegistered = false;
	private boolean proximityEnabled = false;

	private boolean relativeHumidityRegistered = false;
	private boolean relativeHumidityEnabled = false;

	private boolean rotationVectorRegistered = false;
	private boolean rotationVectorEnabled = false;

	private boolean significantMotionRegistered = false;
	private boolean significantMotionEnabled = false;

	private boolean stepCounterRegistered = false;
	private boolean stepCounterEnabled = false;

	private boolean stepDetectorRegistered = false;
	private boolean stepDetectorEnabled = false;

	public SensorModule(){
		super();

        if (TiApplication.getInstance().getSystemService(Context.SENSOR_SERVICE) != null) {
			sensorManager = (SensorManager) TiApplication.getInstance().getSystemService(Context.SENSOR_SERVICE);
		}
	}


	@Kroll.setProperty @Kroll.method
	public void setSensor(int type) {
		if(type == Sensor.TYPE_ACCELEROMETER){
			accelerometerEnabled = true;
		}

		if(type == Sensor.TYPE_MAGNETIC_FIELD){
			magneticFieldEnabled = true;
		}

		if(type == Sensor.TYPE_AMBIENT_TEMPERATURE){
			ambiantTemperatureEnabled = true;
		}

		if(type == Sensor.TYPE_GAME_ROTATION_VECTOR){
			gameRotationVectorEnabled = true;
		}

		if(type == Sensor.TYPE_GEOMAGNETIC_ROTATION_VECTOR){
			geomagneticRotationVectorEnabled = true;
		}

		if(type == Sensor.TYPE_GRAVITY){
			gravityEnabled = true;
		}

		if(type == Sensor.TYPE_GYROSCOPE){
			gyroscopeEnabled = true;
		}

		if(type == Sensor.TYPE_GYROSCOPE_UNCALIBRATED){
			gyroscopeUncalibratedEnabled = true;
		}

		/*if(type == Sensor.TYPE_HEART_RATE){
			heartRateEnabled = true;
			Log.i(LCAT, "In Module - the new value for TYPE_HEART_RATE:" + heartRateEnabled);
		}*/

		if(type == Sensor.TYPE_LIGHT){
			lightEnabled = true;
		}

		if(type == Sensor.TYPE_LINEAR_ACCELERATION){
			linearAccelerationEnabled = true;
		}

		if(type == Sensor.TYPE_MAGNETIC_FIELD_UNCALIBRATED){
			magneticFieldUncalibratedEnabled = true;
		}

		if(type == Sensor.TYPE_ORIENTATION){
			orientationEnabled = true;
		}

		if(type == Sensor.TYPE_PRESSURE){
			pressureEnabled = true;
		}

		if(type == Sensor.TYPE_PROXIMITY){
			proximityEnabled = true;
		}

		if(type == Sensor.TYPE_RELATIVE_HUMIDITY){
			relativeHumidityEnabled = true;
		}

		if(type == Sensor.TYPE_ROTATION_VECTOR){
			rotationVectorEnabled = true;
		}

		if(type == Sensor.TYPE_SIGNIFICANT_MOTION){
			significantMotionEnabled = true;
		}

		if(type == Sensor.TYPE_STEP_COUNTER){
			stepCounterEnabled = true;
		}

		if(type == Sensor.TYPE_STEP_DETECTOR){
			stepDetectorEnabled = true;
		}

	}

	/*
	 * Brightness stuffs
	 */
	@Kroll.method
	protected int getBrightnessMode() {
		try {
			ContentResolver contentResolver = getActivity().getContentResolver();
			int mode = Settings.System.getInt( contentResolver, Settings.System.SCREEN_BRIGHTNESS_MODE);
			return mode;
		} catch (SettingNotFoundException e) {
			return -1;
		}
	}

	@Kroll.setProperty @Kroll.method
	protected void setBrightnessMode(int type) {
		ContentResolver contentResolver = getActivity().getContentResolver();
		Settings.System.putInt(contentResolver, Settings.System.SCREEN_BRIGHTNESS_MODE, type);
	}

	@Kroll.method
	protected int getScreenBrightness() {
		try {
			ContentResolver contentResolver = getActivity().getContentResolver();
			int mode = Settings.System.getInt( contentResolver, android.provider.Settings.System.SCREEN_BRIGHTNESS);
			return mode;
		} catch (SettingNotFoundException e) {
			return -1;
		}
	}

	@Kroll.setProperty @Kroll.method
	protected void setScreenBrightness(int val) {
			ContentResolver contentResolver = getActivity().getContentResolver();
			Settings.System.putInt( contentResolver, android.provider.Settings.System.SCREEN_BRIGHTNESS, val);
	}
	/*
	 * END brightness stuffs
	 */



	/*
	 * Flash light stuffs
	 */

	private Camera camera;
    private boolean isFlashOn;
    private boolean hasFlash;
    Parameters params;
    MediaPlayer mp;

    @Kroll.method
	protected boolean hasFlashLight() {
    	Activity activity = TiApplication.getAppRootOrCurrentActivity();
		boolean hasFlash = activity.getPackageManager().hasSystemFeature(PackageManager.FEATURE_CAMERA_FLASH);
		return hasFlash;
	}

    @Kroll.method
    private void setflashLightOn() {
        if (!isFlashOn) {
        	if (camera == null ) {
        		getCamera();
        	}

            if (camera == null || params == null) {
                return;
            }
            Log.i(LCAT, "setflashLightOn");
            params = camera.getParameters();
            params.setFlashMode(Parameters.FLASH_MODE_TORCH);
            camera.setParameters(params);
            camera.startPreview();
            isFlashOn = true;
        }
    }
    // Get the camera
    private void getCamera() {
        if (camera == null) {
            try {
                camera = Camera.open();
                params = camera.getParameters();
            } catch (RuntimeException e) {
                Log.e("Camera Error. Failed to Open. Error: ", e.getMessage());
            }
        }
    }


    @Kroll.method
    private void setflashLightOff() {
        if (isFlashOn) {
            if (camera == null || params == null) {
                return;
            }
            Log.i(LCAT, "setflashLightOff");
            params = camera.getParameters();
            params.setFlashMode(Parameters.FLASH_MODE_OFF);
            camera.setParameters(params);
            camera.stopPreview();
            isFlashOn = false;
        }
    }



	/*
	 * END Flash light stuffs
	 */



	@Kroll.setProperty @Kroll.method
	protected int[] getSensorList(int type) {
		List<Sensor> sensors = sensorManager.getSensorList(type);
		int[] list = new int[sensors.size()];
		for(int i = 0 ; i < sensors.size() ; i++){
			Sensor sensor = sensors.get(i);
			list[i] = sensor.getType();
		}
	    return list;
	}


	@Kroll.setProperty @Kroll.method
	protected KrollDict getSensorInfos(int type) {
		Sensor sensor = sensorManager.getDefaultSensor(type);
		KrollDict data = new KrollDict();
		if (null != sensor) {
			data.put("name",sensor.getName());
			data.put("constant",sensor.getType());
			data.put("version",sensor.getVersion());
			data.put("resolution",sensor.getResolution());
			data.put("power",sensor.getPower());
			data.put("vendor",sensor.getVendor());
			data.put("maximumRange",sensor.getMaximumRange());
			data.put("minDelay",sensor.getMinDelay());
		}
		 return data;
	}


	@Override
	public void eventListenerAdded(String type, int count, final KrollProxy proxy)
	{
		if (accelerometerEnabled && !accelerometerRegistered) {
			if (EVENT_UPDATE.equals(type)) {
				Log.i(LCAT, "registerListener for ACCELEROMETER:");
				accelerationFilter = new MeanFilter(); // Used for gyro cals
				accelerationFilter.setWindowSize(10);// Used for gyro cals
				TiSensorHelper.registerListener(Sensor.TYPE_ACCELEROMETER, this, SensorManager.SENSOR_DELAY_UI);
				//TiSensorHelper.registerListener(Sensor.TYPE_MAGNETIC_FIELD, this, SensorManager.SENSOR_DELAY_UI);
				accelerometerRegistered = true;
			}
		}

		if (magneticFieldEnabled && !magneticFieldRegistered) {
			if (EVENT_UPDATE.equals(type)) {
				Log.i(LCAT, "registerListener for MAGNETIC_FIELD:");
				magneticFilter = new MeanFilter();// Used for gyro cals
				magneticFilter.setWindowSize(10);// Used for gyro cals
				TiSensorHelper.registerListener(Sensor.TYPE_MAGNETIC_FIELD, this, SensorManager.SENSOR_DELAY_UI);
				magneticFieldRegistered = true;
			}
		}

		if (ambiantTemperatureEnabled && !ambiantTemperatureRegistered) {
			if (EVENT_UPDATE.equals(type)) {
				Log.i(LCAT, "registerListener for TYPE_AMBIENT_TEMPERATURE:");
				TiSensorHelper.registerListener(Sensor.TYPE_AMBIENT_TEMPERATURE, this, SensorManager.SENSOR_DELAY_UI);
				ambiantTemperatureRegistered = true;
			}
		}

		if (gameRotationVectorEnabled && !gameRotationVectorRegistered) {
			if (EVENT_UPDATE.equals(type)) {
				Log.i(LCAT, "registerListener for TYPE_GAME_ROTATION_VECTOR:");
				TiSensorHelper.registerListener(Sensor.TYPE_GAME_ROTATION_VECTOR, this, SensorManager.SENSOR_DELAY_UI);
				gameRotationVectorRegistered = true;
			}
		}

		if (geomagneticRotationVectorEnabled && !geomagneticRotationVectorRegistered) {
			if (EVENT_UPDATE.equals(type)) {
				Log.i(LCAT, "registerListener for TYPE_GEOMAGNETIC_ROTATION_VECTOR:");
				TiSensorHelper.registerListener(Sensor.TYPE_GEOMAGNETIC_ROTATION_VECTOR, this, SensorManager.SENSOR_DELAY_UI);
				geomagneticRotationVectorRegistered = true;
			}
		}

		if (gravityEnabled && !gravityRegistered) {
			if (EVENT_UPDATE.equals(type)) {
				Log.i(LCAT, "registerListener for TYPE_GRAVITY:");
				TiSensorHelper.registerListener(Sensor.TYPE_GRAVITY, this, SensorManager.SENSOR_DELAY_UI);
				gravityRegistered = true;
			}
		}

		if (gyroscopeEnabled && !gyroscopeRegistered) {
			if (EVENT_UPDATE.equals(type)) {
				Log.i(LCAT, "registerListener for TYPE_GYROSCOPE:");
				initGyroMaths();
				TiSensorHelper.registerListener(Sensor.TYPE_GYROSCOPE, this, SensorManager.SENSOR_DELAY_UI);
				gyroscopeRegistered = true;
			}
		}

		if (gyroscopeUncalibratedEnabled && !gyroscopeUncalibratedRegistered) {
			if (EVENT_UPDATE.equals(type)) {
				Log.i(LCAT, "registerListener for TYPE_GYROSCOPE_UNCALIBRATED:");
				TiSensorHelper.registerListener(Sensor.TYPE_GYROSCOPE_UNCALIBRATED, this, SensorManager.SENSOR_DELAY_UI);
				gyroscopeUncalibratedRegistered = true;
			}
		}

		/*if (heartRateEnabled && !heartRateRegistered) {
			if (EVENT_UPDATE.equals(type)) {
				Log.i(LCAT, "registerListener for TYPE_HEART_RATE:");
				TiSensorHelper.registerListener(Sensor.TYPE_HEART_RATE, this, SensorManager.SENSOR_DELAY_UI);
				heartRateRegistered = true;
			}
		}*/

		if (lightEnabled && !lightRegistered) {
			if (EVENT_UPDATE.equals(type)) {
				Log.i(LCAT, "registerListener for TYPE_LIGHT:");
				TiSensorHelper.registerListener(Sensor.TYPE_LIGHT, this, SensorManager.SENSOR_DELAY_UI);
				lightRegistered = true;
			}
		}

		if (linearAccelerationEnabled && !linearAccelerationRegistered) {
			if (EVENT_UPDATE.equals(type)) {
				Log.i(LCAT, "registerListener for TYPE_LINEAR_ACCELERATION:");
				TiSensorHelper.registerListener(Sensor.TYPE_LINEAR_ACCELERATION, this, SensorManager.SENSOR_DELAY_UI);
				linearAccelerationRegistered = true;
			}
		}

		if (magneticFieldUncalibratedEnabled && !magneticFieldUncalibratedRegistered) {
			if (EVENT_UPDATE.equals(type)) {
				Log.i(LCAT, "registerListener for TYPE_MAGNETIC_FIELD_UNCALIBRATED:");
				TiSensorHelper.registerListener(Sensor.TYPE_MAGNETIC_FIELD_UNCALIBRATED, this, SensorManager.SENSOR_DELAY_UI);
				magneticFieldUncalibratedRegistered = true;
			}
		}

		if (orientationEnabled && !orientationRegistered) {
			if (EVENT_UPDATE.equals(type)) {
				Log.i(LCAT, "registerListener for TYPE_ORIENTATION:");
				TiSensorHelper.registerListener(Sensor.TYPE_ORIENTATION, this, SensorManager.SENSOR_DELAY_UI);
				orientationRegistered = true;
			}
		}

		if (pressureEnabled && !pressureRegistered) {
			if (EVENT_UPDATE.equals(type)) {
				Log.i(LCAT, "registerListener for TYPE_PRESSURE:");
				TiSensorHelper.registerListener(Sensor.TYPE_PRESSURE, this, SensorManager.SENSOR_DELAY_UI);
				pressureRegistered = true;
			}
		}

		if (proximityEnabled && !proximityRegistered) {
			if (EVENT_UPDATE.equals(type)) {
				Log.i(LCAT, "registerListener for TYPE_PROXIMITY:");
				TiSensorHelper.registerListener(Sensor.TYPE_PROXIMITY, this, SensorManager.SENSOR_DELAY_UI);
				proximityRegistered = true;
			}
		}

		if (relativeHumidityEnabled && !relativeHumidityRegistered) {
			if (EVENT_UPDATE.equals(type)) {
				Log.i(LCAT, "registerListener for TYPE_RELATIVE_HUMIDITY:");
				TiSensorHelper.registerListener(Sensor.TYPE_RELATIVE_HUMIDITY, this, SensorManager.SENSOR_DELAY_UI);
				relativeHumidityRegistered = true;
			}
		}

		if (rotationVectorEnabled && !rotationVectorRegistered) {
			if (EVENT_UPDATE.equals(type)) {
				Log.i(LCAT, "registerListener for TYPE_ROTATION_VECTOR:");
				TiSensorHelper.registerListener(Sensor.TYPE_ROTATION_VECTOR, this, SensorManager.SENSOR_DELAY_UI);
				rotationVectorRegistered = true;
			}
		}

		if (significantMotionEnabled && !significantMotionRegistered) {
			if (EVENT_UPDATE.equals(type)) {
				Log.i(LCAT, "registerListener for TYPE_SIGNIFICANT_MOTION:");
				mSensor = sensorManager.getDefaultSensor(Sensor.TYPE_SIGNIFICANT_MOTION);
				mTriggerEventListener = new TriggerEventListener() {
				    @Override
				    public void onTrigger(TriggerEvent event) {
				    	KrollDict data = new KrollDict();
						data.put("sType", Sensor.TYPE_SIGNIFICANT_MOTION);
						significantMotionValues = event.values.clone();
						data.put("motion", significantMotionValues[0]);
				    	fireEvent(EVENT_UPDATE, data);
				    	sensorManager.requestTriggerSensor(mTriggerEventListener, mSensor);
				    }
				};
				sensorManager.requestTriggerSensor(mTriggerEventListener, mSensor);
				significantMotionRegistered = true;
			}
		}

		if (stepCounterEnabled && !stepCounterRegistered) {
			if (EVENT_UPDATE.equals(type)) {
				Log.i(LCAT, "registerListener for TYPE_STEP_COUNTER:");
				TiSensorHelper.registerListener(Sensor.TYPE_STEP_COUNTER, this, SensorManager.SENSOR_DELAY_FASTEST);
				stepCounterRegistered = true;
			}
		}

		if (stepDetectorEnabled && !stepDetectorRegistered) {
			if (EVENT_UPDATE.equals(type)) {
				Log.i(LCAT, "registerListener for TYPE_STEP_DETECTOR:");
				TiSensorHelper.registerListener(Sensor.TYPE_STEP_DETECTOR, this, SensorManager.SENSOR_DELAY_FASTEST);
				stepDetectorRegistered = true;
			}
		}
		super.eventListenerAdded(type, count, proxy);
	}

	@Override
	public void eventListenerRemoved(String type, int count, KrollProxy proxy)
	{
		if (accelerometerRegistered) {
			if (EVENT_UPDATE.equals(type)) {
				TiSensorHelper.unregisterListener(Sensor.TYPE_ACCELEROMETER, this);
				accelerometerRegistered = false;
			}
		}
		if (magneticFieldRegistered) {
			if (EVENT_UPDATE.equals(type)) {
				TiSensorHelper.unregisterListener(Sensor.TYPE_MAGNETIC_FIELD, this);
				magneticFieldRegistered = false;
			}
		}


		if (ambiantTemperatureRegistered) {
			if (EVENT_UPDATE.equals(type)) {
				TiSensorHelper.unregisterListener(Sensor.TYPE_AMBIENT_TEMPERATURE, this);
				ambiantTemperatureRegistered = false;
			}
		}

		if (gameRotationVectorRegistered) {
			if (EVENT_UPDATE.equals(type)) {
				TiSensorHelper.unregisterListener(Sensor.TYPE_GAME_ROTATION_VECTOR, this);
				gameRotationVectorRegistered = false;
			}
		}

		if (geomagneticRotationVectorRegistered) {
			if (EVENT_UPDATE.equals(type)) {
				TiSensorHelper.unregisterListener(Sensor.TYPE_GEOMAGNETIC_ROTATION_VECTOR, this);
				geomagneticRotationVectorRegistered = false;
			}
		}

		if (gravityRegistered) {
			if (EVENT_UPDATE.equals(type)) {
				TiSensorHelper.unregisterListener(Sensor.TYPE_GRAVITY, this);
				gravityRegistered = false;
			}
		}

		if (gyroscopeRegistered) {
			if (EVENT_UPDATE.equals(type)) {
				TiSensorHelper.unregisterListener(Sensor.TYPE_GYROSCOPE, this);
				gyroscopeRegistered = false;
			}
		}

		if (gyroscopeUncalibratedRegistered) {
			if (EVENT_UPDATE.equals(type)) {
				TiSensorHelper.unregisterListener(Sensor.TYPE_GYROSCOPE_UNCALIBRATED, this);
				gyroscopeUncalibratedRegistered = false;
			}
		}

		/*if (heartRateRegistered) {
			if (EVENT_UPDATE.equals(type)) {
				TiSensorHelper.unregisterListener(Sensor.TYPE_HEART_RATE, this);
				heartRateRegistered = false;
			}
		}*/

		if (lightRegistered) {
			if (EVENT_UPDATE.equals(type)) {
				TiSensorHelper.unregisterListener(Sensor.TYPE_LIGHT, this);
				lightRegistered = false;
			}
		}

		if (linearAccelerationRegistered) {
			if (EVENT_UPDATE.equals(type)) {
				TiSensorHelper.unregisterListener(Sensor.TYPE_LINEAR_ACCELERATION, this);
				linearAccelerationRegistered = false;
			}
		}

		if (magneticFieldUncalibratedRegistered) {
			if (EVENT_UPDATE.equals(type)) {
				TiSensorHelper.unregisterListener(Sensor.TYPE_MAGNETIC_FIELD_UNCALIBRATED, this);
				magneticFieldUncalibratedRegistered = false;
			}
		}

		if (orientationRegistered) {
			if (EVENT_UPDATE.equals(type)) {
				TiSensorHelper.unregisterListener(Sensor.TYPE_ORIENTATION, this);
				orientationRegistered = false;
			}
		}

		if (pressureRegistered) {
			if (EVENT_UPDATE.equals(type)) {
				TiSensorHelper.unregisterListener(Sensor.TYPE_PRESSURE, this);
				pressureRegistered = false;
			}
		}

		if (proximityRegistered) {
			if (EVENT_UPDATE.equals(type)) {
				TiSensorHelper.unregisterListener(Sensor.TYPE_PROXIMITY, this);
				proximityRegistered = false;
			}
		}

		if (relativeHumidityRegistered) {
			if (EVENT_UPDATE.equals(type)) {
				TiSensorHelper.unregisterListener(Sensor.TYPE_RELATIVE_HUMIDITY, this);
				relativeHumidityRegistered = false;
			}
		}

		if (rotationVectorRegistered) {
			if (EVENT_UPDATE.equals(type)) {
				TiSensorHelper.unregisterListener(Sensor.TYPE_ROTATION_VECTOR, this);
				rotationVectorRegistered = false;
			}
		}

		if (significantMotionRegistered) {
			if (EVENT_UPDATE.equals(type)) {
				TiSensorHelper.unregisterListener(Sensor.TYPE_SIGNIFICANT_MOTION, this);
				significantMotionRegistered = false;
			}
		}

		if (stepCounterRegistered) {
			if (EVENT_UPDATE.equals(type)) {
				TiSensorHelper.unregisterListener(Sensor.TYPE_STEP_COUNTER, this);
				stepCounterRegistered = false;
			}
		}

		if (stepDetectorRegistered) {
			if (EVENT_UPDATE.equals(type)) {
				TiSensorHelper.unregisterListener(Sensor.TYPE_STEP_DETECTOR, this);
				stepDetectorRegistered = false;
			}
		}
		setflashLightOff();
		super.eventListenerRemoved(type, count, proxy);
	}



	public void onAccuracyChanged(Sensor sensor, int accuracy)
	{
	}


	// Used by TYPE_ACCELEROMETER
	float[] gravity = new float[3];
	private long lastSensorAccelerometerEventTimestamp = 0;
	private float[] accellerometerValues = null;
	private MeanFilter accelerationFilter;

	// Used by TYPE_MAGNETIC_FIELD
	private float[] magneticFieldValues = null;
	private float[] R = new float[16];
	private float[] I = new float[16];
	private float[] orientation = new float[3];
	private float[] outR = new float[16];
	private float[] orientationPitchRollAzimuth = new float[3];
	// Used by TYPE_AMBIENT_TEMPERATURE
	private float[] ambiantTemperatureValues = null;
	// Used by TYPE_GAME_ROTATION_VECTOR
	private float[] gameRotationVectorValues = null;
	// Used by TYPE_GEOMAGNETIC_ROTATION_VECTOR
	private float[] geomagneticRotationVectorValues = null;
	// Used by TYPE_GRAVITY
	private float[] gravityValues = null;
	// Used by TYPE_GYROSCOPE
	private long lastSensorGyroscopeEventTimestamp = 0;
	private static final float NS2S = 1.0f / 1000000000.0f;
    private final float[] deltaRotationVector = new float[4];
    private float[] deltaRotationMatrix = new float[9];
    private float[] currentRotationMatrix = new float[9];
    private static final float EPSILON = 0.000001f;
    private int accelerationSampleCount = 0; // Count used by accelerometer to set the first initial orientation.
	private int magneticSampleCount = 0; // Count used by accelerometer to set the first initial orientation.
	private float[] gyroscopeValues = null;
	private float[] gyroscopeOrientation;
	private boolean hasInitialOrientation = false;
	private float[] initialRotationMatrix;
	private boolean stateInitializedCalibrated = false;

	private MeanFilter magneticFilter;
	// Used by TYPE_GYROSCOPE_UNCALIBRATED
	private float[] gyroscopeUncalibratedValues = null;
	// Used by TYPE_HEART_RATE
	private float[] heartRateValues = null;
	// Used by TYPE_LIGHT
	private float[] lightValues = null;
	// Used by TYPE_LINEAR_ACCELERATION
	private float[] linearAccelerationValues = null;
	// Used by TYPE_MAGNETIC_FIELD_UNCALIBRATED
	private float[] magneticFieldUncalibratedValues = null;
	// Used by TYPE_ORIENTATION
	private float[] orientationValues = null;
	// Used by TYPE_PRESSURE
	private float[] pressureValues = null;
	// Used by TYPE_PROXIMITY
	private float[] proximityValues = null;
	// Used by TYPE_RELATIVE_HUMIDITY
	private float[] relativeHumidityValues = null;
	// Used by TYPE_ROTATION_VECTOR
	private float[] rotationVectorValues = null;
	// Used by TYPE_SIGNIFICANT_MOTION
	private float[] significantMotionValues = null;
	// Used by TYPE_STEP_COUNTER
	private float[] stepCounterValues = null;
	private float stepCounterOffset;
	// Used by TYPE_STEP_DETECTOR
	private float[] stepDetectorValues = null;
	private int stepDetectorCounter;


	public void onSensorChanged(SensorEvent event) {

		KrollDict data = new KrollDict();
		data.put("sType", event.sensor.getType());
		switch (event.sensor.getType()) {
			case Sensor.TYPE_ACCELEROMETER:
				if (event.timestamp - lastSensorAccelerometerEventTimestamp > 100) {
					accellerometerValues = event.values.clone();
						accellerometerValues = accelerationFilter.filterFloat(accellerometerValues); // Use a mean filter to smooth the sensor inputs
						accelerationSampleCount++; // Count the number of samples received.

						// Only determine the initial orientation after the acceleration sensor
						// and magnetic sensor have had enough time to be smoothed by the mean
						// filters. Also, only do this if the orientation hasn't already been
						// determined since we only need it once.
						if (accelerationSampleCount > 30
								&& magneticSampleCount > 30
								&& !hasInitialOrientation) {
							calculateOrientation();
						}
					// End gyroscope stuffs

					lastSensorAccelerometerEventTimestamp = event.timestamp;

				    float[] linear_acceleration = new float[3];
				    final float alpha = (float) 0.8;

			        gravity[0] = alpha * gravity[0] + (1 - alpha) * accellerometerValues[0];
			        gravity[1] = alpha * gravity[1] + (1 - alpha) * accellerometerValues[1];
			        gravity[2] = alpha * gravity[2] + (1 - alpha) * accellerometerValues[2];

			        linear_acceleration[0] = accellerometerValues[0] - gravity[0];
			        linear_acceleration[1] = accellerometerValues[1] - gravity[1];
			        linear_acceleration[2] = accellerometerValues[2] - gravity[2];

					float x = accellerometerValues[0];
					float y = accellerometerValues[1];
					float z = accellerometerValues[2];

					data.put("x", x);
					data.put("y", y);
					data.put("z", z);
					data.put("linearAccelerationX", linear_acceleration[0]);
					data.put("linearAccelerationY", linear_acceleration[1]);
					data.put("linearAccelerationZ", linear_acceleration[2]);
				}
			break;
			case Sensor.TYPE_MAGNETIC_FIELD:
				magneticFieldValues = event.values.clone();
				// Gyroscope stuffs.
				magneticFieldValues = magneticFilter.filterFloat(magneticFieldValues);// Use a mean filter to smooth the sensor inputs
				magneticSampleCount++;// Count the number of samples received.
				// End gyroscope stuffs

				double magnetometer = Math.sqrt(Math.pow(magneticFieldValues[0], 2) + Math.pow( magneticFieldValues[1], 2) + Math.pow(magneticFieldValues[2], 2));
				data.put("magnetometer", magnetometer);
				data.put("x", magneticFieldValues[0]);
				data.put("y", magneticFieldValues[1]);
				data.put("z", magneticFieldValues[2]);

				if(accellerometerValues!=null && magneticFieldValues!=null){

					boolean success = SensorManager.getRotationMatrix(R, I, accellerometerValues, magneticFieldValues);
					SensorManager.remapCoordinateSystem(R, SensorManager.AXIS_X, SensorManager.AXIS_Z, outR);
					if (success) {
						SensorManager.getOrientation(R, orientation);
						float azimuthInDegress =  (float) (Math.toDegrees(orientation[0])+360) % 360;
						data.put("compassRotation", azimuthInDegress);
					}
					SensorManager.getOrientation(outR, orientationPitchRollAzimuth);
					data.put("azimuth", orientationPitchRollAzimuth[0]);
					data.put("pitch", orientationPitchRollAzimuth[1]);
					data.put("roll", orientationPitchRollAzimuth[2]);
				}
				break;
			case Sensor.TYPE_AMBIENT_TEMPERATURE:
				ambiantTemperatureValues = event.values.clone();
				data.put("celcius", ambiantTemperatureValues[0]);
				data.put("fahrenheit",  ((ambiantTemperatureValues[0]*9)/5)+32  );
				break;
			case Sensor.TYPE_GAME_ROTATION_VECTOR:
				// Approfondire la sortie des infos avec cet example
				// https://github.com/kplatfoot/android-rotation-sensor-sample/blob/master/src/com/kviation/android/sample/orientation/Orientation.java
				/*
				http://developer.android.com/reference/android/hardware/SensorEvent.html#values
				values[0]: x*sin(θ/2)
				values[1]: y*sin(θ/2)
				values[2]: z*sin(θ/2)
				values[3]: cos(θ/2)
				values[4]: estimated heading Accuracy (in radians) (-1 if unavailable)
				*/
				gameRotationVectorValues = event.values.clone();
				data.put("x", gameRotationVectorValues[0]);
				data.put("y", gameRotationVectorValues[1]);
				data.put("z", gameRotationVectorValues[2]);
				data.put("cos", gameRotationVectorValues[3]);
				//data.put("headingAccuracy", gameRotationVectorValues[4]);
				break;
			case Sensor.TYPE_GEOMAGNETIC_ROTATION_VECTOR:
				geomagneticRotationVectorValues = event.values.clone();
				data.put("x", geomagneticRotationVectorValues[0]);
				data.put("y", geomagneticRotationVectorValues[1]);
				data.put("z", geomagneticRotationVectorValues[2]);
				break;
			case Sensor.TYPE_GRAVITY:
				gravityValues = event.values.clone();
				data.put("x", gravityValues[0]);
				data.put("y", gravityValues[1]);
				data.put("z", gravityValues[2]);
				break;
			case Sensor.TYPE_GYROSCOPE:
				gyroscopeValues = event.values.clone();
				// from http://developer.android.com/reference/android/hardware/SensorEvent.html#values
				// http://www.kircherelectronics.com/blog/index.php/11-android/sensors/16-android-gyroscope-fusion

				// This timestep's delta rotation to be multiplied by the current rotation
		        // after computing it from the gyro sample data.
				if (!hasInitialOrientation){
					return;
				}
				// Initialization of the gyroscope based rotation matrix
		        if (!stateInitializedCalibrated){
		            currentRotationMatrix = matrixMultiplication(currentRotationMatrix, initialRotationMatrix);
		            stateInitializedCalibrated = true;
		        }

		        if (lastSensorGyroscopeEventTimestamp != 0 && stateInitializedCalibrated) {
		        	final float dT = (event.timestamp - lastSensorGyroscopeEventTimestamp) * NS2S;
		            // Axis of the rotation sample, not normalized yet.
					float axisX = gyroscopeValues[0];
					float axisY = gyroscopeValues[1];
					float axisZ = gyroscopeValues[2];

		            // Calculate the angular speed of the sample
		            float omegaMagnitude = (float) Math.sqrt(axisX*axisX + axisY*axisY + axisZ*axisZ);

		            // Normalize the rotation vector if it's big enough to get the axis
		            if (omegaMagnitude > EPSILON) {
						axisX /= omegaMagnitude;
						axisY /= omegaMagnitude;
						axisZ /= omegaMagnitude;
            		}

					// Integrate around this axis with the angular speed by the timestep
					// in order to get a delta rotation from this sample over the timestep
					// We will convert this axis-angle representation of the delta rotation
					// into a quaternion before turning it into the rotation matrix.
					float thetaOverTwo = omegaMagnitude * dT / 2.0f;
					float sinThetaOverTwo = (float) Math.sin(thetaOverTwo);
					float cosThetaOverTwo = (float) Math.cos(thetaOverTwo);
					deltaRotationVector[0] = sinThetaOverTwo * axisX;
					deltaRotationVector[1] = sinThetaOverTwo * axisY;
					deltaRotationVector[2] = sinThetaOverTwo * axisZ;
					deltaRotationVector[3] = cosThetaOverTwo;

					SensorManager.getRotationMatrixFromVector(deltaRotationMatrix, deltaRotationVector);
					// User code should concatenate the delta rotation we computed with the current rotation
					// in order to get the updated rotation.
					currentRotationMatrix = matrixMultiplication( currentRotationMatrix,  deltaRotationMatrix );
					SensorManager.getOrientation( currentRotationMatrix, gyroscopeOrientation );

					data.put("x", gyroscopeValues[0]);
					data.put("y", gyroscopeValues[1]);
					data.put("z", gyroscopeValues[2]);
					data.put("radianX", gyroscopeOrientation[0]);
					data.put("radianY", gyroscopeOrientation[1]);
					data.put("radianZ", gyroscopeOrientation[2]);
					data.put("degreesX", Math.toDegrees(gyroscopeOrientation[0]));
					data.put("degreesY", Math.toDegrees(gyroscopeOrientation[1]));
					data.put("degreesZ", Math.toDegrees(gyroscopeOrientation[2]));
		        }
				lastSensorGyroscopeEventTimestamp = event.timestamp;
				break;
			case Sensor.TYPE_GYROSCOPE_UNCALIBRATED:
				gyroscopeUncalibratedValues = event.values.clone();
				break;
			/*case Sensor.TYPE_HEART_RATE:
				heartRateValues = event.values.clone();
				data.put("rate", x);
				break;*/
			case Sensor.TYPE_LIGHT:
				lightValues = event.values.clone();
				data.put("lux", lightValues[0]);
				break;
			case Sensor.TYPE_LINEAR_ACCELERATION:
				linearAccelerationValues = event.values.clone();

				float x = linearAccelerationValues[0];
				float y = linearAccelerationValues[1];
				float z = linearAccelerationValues[2];

				data.put("x", x);
				data.put("y", y);
				data.put("z", z);
				break;
			case Sensor.TYPE_MAGNETIC_FIELD_UNCALIBRATED:
				magneticFieldUncalibratedValues = event.values.clone();
				data.put("x_uncalib", magneticFieldUncalibratedValues[0]);
				data.put("y_uncalib", magneticFieldUncalibratedValues[1]);
				data.put("z_uncalib", magneticFieldUncalibratedValues[2]);
				data.put("x_bias", magneticFieldUncalibratedValues[3]);
				data.put("y_bias", magneticFieldUncalibratedValues[4]);
				data.put("z_bias", magneticFieldUncalibratedValues[5]);
				break;
			case Sensor.TYPE_PROXIMITY:
				proximityValues = event.values.clone();
				data.put("cm", proximityValues[0]);
				break;
			case Sensor.TYPE_RELATIVE_HUMIDITY:
				relativeHumidityValues = event.values.clone();
				data.put("percent", relativeHumidityValues[0]);
				break;
			case Sensor.TYPE_ROTATION_VECTOR:
				rotationVectorValues = event.values.clone();
				data.put("x", rotationVectorValues[0]);
				data.put("y", rotationVectorValues[1]);
				data.put("z", rotationVectorValues[2]);
				data.put("cos", rotationVectorValues[3]);
				data.put("headingAccuracy", rotationVectorValues[4]);
				break;
			case Sensor.TYPE_SIGNIFICANT_MOTION:
				significantMotionValues = event.values.clone();
				Log.i(LCAT, "TYPE_SIGNIFICANT_MOTION:"+significantMotionValues[0]);
				data.put("motion", significantMotionValues[0]);
				break;
			case Sensor.TYPE_STEP_COUNTER:
				stepCounterValues = event.values.clone();
				if (stepCounterOffset == 0) {
					stepCounterOffset = stepCounterValues[0];
		        }
				data.put("val", stepCounterValues[0]);
				data.put("count", stepCounterValues[0] - stepCounterOffset);
				break;
			case Sensor.TYPE_ORIENTATION:
				orientationValues = event.values.clone();
				data.put("orientation", orientationValues[0]);
				data.put("pitch", orientationValues[1]);
				data.put("roll", orientationValues[2]);
				break;
			case Sensor.TYPE_STEP_DETECTOR:
				stepDetectorValues = event.values.clone();
				if (stepDetectorValues[0] == 1.0f) {
					stepDetectorCounter++;
		        }
				data.put("count", stepDetectorCounter);
				break;
		}
		fireEvent(EVENT_UPDATE, data);
	}

	@Kroll.onAppCreate
	public static void onAppCreate(TiApplication app) {
		Log.d(LCAT, "inside onAppCreate");
	}



	private float[] matrixMultiplication(float[] a, float[] b)
    {
        float[] result = new float[9];

        result[0] = a[0] * b[0] + a[1] * b[3] + a[2] * b[6];
        result[1] = a[0] * b[1] + a[1] * b[4] + a[2] * b[7];
        result[2] = a[0] * b[2] + a[1] * b[5] + a[2] * b[8];

        result[3] = a[3] * b[0] + a[4] * b[3] + a[5] * b[6];
        result[4] = a[3] * b[1] + a[4] * b[4] + a[5] * b[7];
        result[5] = a[3] * b[2] + a[4] * b[5] + a[5] * b[8];

        result[6] = a[6] * b[0] + a[7] * b[3] + a[8] * b[6];
        result[7] = a[6] * b[1] + a[7] * b[4] + a[8] * b[7];
        result[8] = a[6] * b[2] + a[7] * b[5] + a[8] * b[8];

        return result;
    }
	private void calculateOrientation()
	{
		initialRotationMatrix = new float[9];
		if (accellerometerValues != null && magneticFieldValues != null) {
			hasInitialOrientation = SensorManager.getRotationMatrix(
					initialRotationMatrix, null, accellerometerValues, magneticFieldValues);
		}

	}

	private void initGyroMaths(){
		initialRotationMatrix = new float[9];
		gyroscopeOrientation = new float[3];
		// Initialize the current rotation matrix as an identity matrix.
		currentRotationMatrix[0] = 1.0f;
		currentRotationMatrix[4] = 1.0f;
		currentRotationMatrix[8] = 1.0f;

	}


	@Override
	public void onStop(Activity activity)
	{
		super.onStop(activity);
	}

	@Override
	public void onPause(Activity activity)
	{
		super.onPause(activity);
		if (significantMotionEnabled && significantMotionRegistered) {
			sensorManager.cancelTriggerSensor(mTriggerEventListener, mSensor);
		}

	}

	@Override
	public void onResume(Activity activity)
	{
		super.onResume(activity);
		if (significantMotionEnabled && significantMotionRegistered) {
			sensorManager.requestTriggerSensor(mTriggerEventListener, mSensor);
		}
	}

	@Override
	public void onDestroy(Activity activity)
	{
		super.onDestroy(activity);
	}
}
